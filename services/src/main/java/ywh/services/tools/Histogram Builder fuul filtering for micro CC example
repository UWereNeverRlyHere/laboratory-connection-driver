package ywh.services.tools;

import lombok.Getter;
import lombok.Setter;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.ValueMarker;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYAreaRenderer;
import org.jfree.chart.title.TextTitle;
import org.jfree.chart.ui.HorizontalAlignment;
import org.jfree.chart.ui.Layer;
import org.jfree.chart.ui.RectangleInsets;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import ywh.commons.ImageUtils;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;

/**
 * Step-builder для генерації кількох гістограм і повернення Map&lt;name, base64&gt;.
 * <p>
 * HistogramBuilder.start()
 * .addGraph("WBC", 400, points).withMarkers(lanes)
 * .addGraph("RBC", 300, points).skipMarkers()
 * .build();
 */
public final class HistogramBuilder {

    /* ───────────── step-інтерфейси ───────────── */
    public interface GraphStep {
        MarkerStep addGraph(String name, double max, List<String> points);

        MarkerStep addWbc(double max, List<String> points);

        MarkerStep addRbc(double max, List<String> points);

        MarkerStep addPlt(double max, List<String> points);

        Map<String, String> build();
    }

    public interface MarkerStep {
        GraphStep withMarkers(List<String> lanes, boolean lanesWithCoeff);

        GraphStep skipMarkers();                   // якщо маркери не потрібні
    }

    /* ───────────── factory-метод для старту ───────────── */
    public static GraphStep start() {
        return new Builder();
    }

    /* ───────────── внутрішня реалізація ───────────── */
    private static final class Builder implements GraphStep, MarkerStep {

        /* ------------ модель одного графіка ------------ */
        private record Task(String name, double max, List<String> points, List<String> lanes, boolean lanesWithCoeff) {
        }

        private final List<Task> tasks = new ArrayList<>();

        /* ------------ маркерний буфер ------------ */
        private String tmpName;
        private double tmpMax;
        private List<String> tmpPoints;
        private List<String> tmpLanes;

        /* ===== GraphStep ===== */
        @Override
        public MarkerStep addGraph(String name, double max, List<String> points) {
            Objects.requireNonNull(name);
            this.tmpName = name;
            this.tmpMax = max;
            this.tmpPoints = points;
            return this;                    // → MarkerStep
        }

        @Override
        public MarkerStep addWbc(double max, List<String> points) {
            return addGraph("WBC", max, points);
        }

        @Override
        public MarkerStep addRbc(double max, List<String> points) {
            return addGraph("RBC", max, points);
        }

        @Override
        public MarkerStep addPlt(double max, List<String> points) {
            return addGraph("PLT", max, points);
        }

        @Override
        public Map<String, String> build() {
            LinkedHashMap<String, String> res = new LinkedHashMap<>();
            for (Task t : tasks) {
                res.put(t.name, renderGraph(t));
            }
            return res;
        }

        /* ===== MarkerStep ===== */
        @Override
        public GraphStep withMarkers(List<String> lanes, boolean lanesWithCoeff) {
            tasks.add(new Task(tmpName, tmpMax, tmpPoints, lanes, lanesWithCoeff));
            clearTmp();
            return this;                    // → GraphStep
        }

        @Override
        public GraphStep skipMarkers() {
            tasks.add(new Task(tmpName, tmpMax, tmpPoints, List.of(), false));
            clearTmp();
            return this;                    // → GraphStep
        }

        private void clearTmp() {
            tmpName = null;
            tmpPoints = null;
            tmpLanes = null;
            tmpMax = 0;
        }

        /* ------------ логіка рендеру (адаптована з попередньої версії) ------------ */
        private final XYSeriesCollection dataset = new XYSeriesCollection();
        private XYPlot plot;
        private JFreeChart chart;
        @Setter
        @Getter
        private String color;
        @Getter
        private String graphName;
        private String imageString;
        private double lowerThreshold = 0; // додаємо поле для порогу детекції
        private double[] anchors = null;  // додаємо для збереження анкорів

        private String renderGraph(Task t) {
            createChart(t.name);

            // Витягуємо анкори з маркерів
            if (!t.lanes.isEmpty()) {
                try {
                    // Для WBC: 4 маркери -> 5 анкорів (включаємо 0.0 на початку)
                    anchors = new double[t.lanes.size() + 1];
                    anchors[0] = 0.0;
                    for (int i = 0; i < t.lanes.size(); i++) {
                        anchors[i + 1] = Double.parseDouble(t.lanes.get(i));
                    }
                    lowerThreshold = anchors[1]; // перший маркер
                } catch (NumberFormatException e) {
                    anchors = null;
                    lowerThreshold = 0;
                }
            }

            setDataset(t.points, t.max);

            // Відображаємо маркери
            double coeff = t.lanesWithCoeff ? t.max / t.points.size() : 1;
            for (String lane : t.lanes) {
                setMarker(String.valueOf(Double.parseDouble(lane) * coeff));
            }

            generateImage();

            // Скидаємо після використання
            lowerThreshold = 0;
            anchors = null;

            return imageString;
        }

        /* --- нижче залишено майже без змін --- */
        private void setGraphName(String name) {
            this.graphName = "Гістограма розподілення " + name + " за розмірами";
        }

        private void setDataset(List<String> data, double max) {
            XYSeries series = new XYSeries("");

            // Парсимо дані
            List<Double> rawPoints = new ArrayList<>();
            for (int i = 0; i < data.size() - 1; i++) {
                double y;
                try {
                    y = Double.parseDouble(data.get(i));
                } catch (NumberFormatException ex) {
                    y = Double.parseDouble(data.get(i + 1));
                    i++;
                }
                rawPoints.add(y);
            }

            // Для WBC застосовуємо спеціальну обробку
            if (graphName != null && graphName.contains("лейкоцитів") && lowerThreshold > 0) {
                // Використовуємо сегментне мапування
                List<Double> processed = processWbcSegmented(rawPoints, max);
                for (int i = 0; i < processed.size(); i++) {
                    series.add(i, processed.get(i)); // X = просто індекс (0..400)
                }
            } else {
                // Звичайна обробка для інших графіків
                double step = max / rawPoints.size();
                for (int i = 0; i < rawPoints.size(); i++) {
                    series.add(i * step, rawPoints.get(i));
                }
            }

            dataset.addSeries(series);
        }

        /**
         * Сегментна обробка WBC (аналог Python-коду)
         */
        private List<Double> processWbcSegmented(List<Double> rawPoints, double xMax) {
            // Якщо анкори не визначені, повертаємо прості дані
            if (anchors == null || anchors.length < 5) {
                return rawPoints;
            }

            int targetLen = (int) xMax + 1; // 401 точка для діапазону 0..400

            // Використовуємо РЕАЛЬНІ анкори з аналізатора
            // anchors вже містить: {0.0, 64.06, 114.06, 125.00, 400}

            // Розподіляємо баіни по сегментах пропорційно довжинам
            int[] binsPerSegment = distributeBinsAcrossSegments(anchors, rawPoints.size());

            // Будуємо X-позиції для кожного баіну
            double[] xsBins = buildBinPositions(anchors, binsPerSegment, rawPoints.size());

            // Інтерполяція + аподизація (використовуємо anchors[1] як поріг)
            double[] interpolated = interpolateAndApodize(xsBins, rawPoints, targetLen, anchors[1], 0.10);

            // Згладжування Гауса
            double[] smoothed = gaussianFilter1d(interpolated, 4.0);

            // Застосування порогу (thresholding)
            double threshold = 0.2;
            List<Double> result = new ArrayList<>();
            for (double v : smoothed) {
                result.add(v < threshold ? 0.0 : v);
            }

            return result;
        }

        /**
         * Розподіл баінів по сегментах пропорційно довжинам
         */
        private int[] distributeBinsAcrossSegments(double[] anchors, int totalBins) {
            int nSegments = anchors.length - 1;
            double[] segLengths = new double[nSegments];
            double totalLength = 0;

            for (int i = 0; i < nSegments; i++) {
                segLengths[i] = anchors[i + 1] - anchors[i];
                totalLength += segLengths[i];
            }

            int[] binsPerSeg = new int[nSegments];
            int allocated = 0;

            for (int i = 0; i < nSegments; i++) {
                binsPerSeg[i] = (int) Math.floor(segLengths[i] / totalLength * totalBins);
                allocated += binsPerSeg[i];
            }

            // Розподіляємо залишок
            int remaining = totalBins - allocated;
            for (int i = 0; i < remaining; i++) {
                binsPerSeg[i % nSegments]++;
            }

            return binsPerSeg;
        }
        /**
         * Будуємо X-позиції для баінів (центровані в сегментах)
         */
        private double[] buildBinPositions(double[] anchors, int[] binsPerSeg, int totalBins) {
            List<Double> xsBinsList = new ArrayList<>();

            for (int segIdx = 0; segIdx < binsPerSeg.length; segIdx++) {
                int m = binsPerSeg[segIdx];
                if (m <= 0) continue;

                double x0 = anchors[segIdx];
                double L = anchors[segIdx + 1] - x0;

                for (int k = 0; k < m; k++) {
                    double rel = (k + 0.5) / m;
                    xsBinsList.add(x0 + rel * L);
                }
            }

            return xsBinsList.stream().mapToDouble(Double::doubleValue).toArray();
        }

        /**
         * Інтерполяція (лінійна) + аподизація (зануляємо зліва)
         */
        private double[] interpolateAndApodize(double[] xsBins, List<Double> y, int targetLen, double anchorX, double leftFrac) {
            double[] result = new double[targetLen];

            // Проста лінійна інтерполяція
            for (int i = 0; i < targetLen; i++) {
                double x = i;

                // Знаходимо найближчі точки
                int idx = 0;
                while (idx < xsBins.length - 1 && xsBins[idx] < x) {
                    idx++;
                }

                if (idx == 0) {
                    result[i] = y.get(0);
                } else if (idx >= xsBins.length) {
                    result[i] = y.get(y.size() - 1);
                } else {
                    // Лінійна інтерполяція
                    double x0 = xsBins[idx - 1];
                    double x1 = xsBins[idx];
                    double y0 = y.get(idx - 1);
                    double y1 = y.get(idx);
                    double t = (x - x0) / (x1 - x0);
                    result[i] = y0 + t * (y1 - y0);
                }
            }

            // Аподизація (зануляємо зліва)
            double x0 = anchorX * (1.0 - leftFrac);
            for (int i = 0; i < targetLen; i++) {
                double x = i;
                if (x < x0) {
                    result[i] = 0.0;
                } else if (x <= anchorX) {
                    // Косинусна рампа
                    double t = (x - x0) / (anchorX - x0);
                    double w = 0.5 * (1 - Math.cos(Math.PI * t));
                    result[i] *= w;
                }
            }

            return result;
        }

        /**
         * Гаусівське згладжування 1D
         */
        private double[] gaussianFilter1d(double[] data, double sigma) {
            int windowSize = (int) Math.ceil(sigma * 6); // ±3σ
            if (windowSize % 2 == 0) windowSize++;

            int halfWindow = windowSize / 2;
            double[] weights = new double[windowSize];
            double sum = 0;

            // Генеруємо гаусівські ваги
            for (int i = 0; i < windowSize; i++) {
                double x = i - halfWindow;
                weights[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
                sum += weights[i];
            }

            // Нормалізуємо
            for (int i = 0; i < windowSize; i++) {
                weights[i] /= sum;
            }

            // Застосовуємо фільтр
            double[] result = new double[data.length];
            for (int i = 0; i < data.length; i++) {
                double value = 0;
                for (int j = -halfWindow; j <= halfWindow; j++) {
                    int idx = i + j;
                    if (idx >= 0 && idx < data.length) {
                        value += data[idx] * weights[j + halfWindow];
                    }
                }
                result[i] = value;
            }

            return result;
        }

        private void setMarker(String index) {
            ValueMarker marker = new ValueMarker(Double.parseDouble(index));
            marker.setPaint(Color.black);
            marker.setStroke(new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
                    BasicStroke.JOIN_MITER, 10.0f, new float[]{10.0f}, 0.0f));
            plot.addDomainMarker(marker, Layer.FOREGROUND);
        }

        private void generateImage() {
            XYAreaRenderer render = new XYAreaRenderer();
            render.setSeriesPaint(0, Color.decode(getColor()));
            render.setSeriesStroke(0, new BasicStroke(2.5f));
            render.setOutline(true);

            plot.setDataset(dataset);
            plot.setRenderer(0, render);

            BufferedImage img = chart.createBufferedImage(450, 200, null);
            imageString = ImageUtils.encodePngToBase64(img);
            dataset.removeAllSeries();
        }

        private void createChart(String name) {
            switch (name) {
                case "WBC" -> {
                    setGraphName("лейкоцитів");
                    setColor("#FFF5DD");
                }
                case "WBC-LYM-MONO" -> {
                    setGraphName("лейкоцитів \n (лімфоцитів та моноцитів) ");
                    setColor("#FFF5DD");
                }
                case "WBC-MONO-POLY" -> {
                    setGraphName("лейкоцитів \n (одноядерних та поліморфноядерних) ");
                    setColor("#FFF5DD");
                }
                case "RBC" -> {
                    setGraphName("еритроцитів");
                    setColor("#9E021E");
                }
                case "PLT" -> {
                    setGraphName("тромбоцитів");
                    setColor("#315691");
                }
                default -> {
                    setGraphName(name);
                    setColor("#000000");
                }
            }
            chart = ChartFactory.createXYLineChart(
                    getGraphName(), null, null, null,
                    PlotOrientation.VERTICAL, false, false, false);
            plot = chart.getXYPlot();

            /* базове оформлення */
            chart.setBackgroundPaint(Color.white);
            TextTitle t = chart.getTitle();
            t.setHorizontalAlignment(HorizontalAlignment.CENTER);
            t.setPaint(Color.black);
            t.setFont(new Font("Comic Sans MS", Font.ITALIC, 16));
            plot.setBackgroundPaint(new Color(232, 232, 232));
            plot.setDomainGridlinePaint(Color.gray);
            plot.setRangeGridlinePaint(Color.gray);
            plot.setAxisOffset(new RectangleInsets(1.0, 1.0, 1.0, 1.0));

            ValueAxis axis = plot.getDomainAxis();
            axis.setAxisLineVisible(false);
            NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();
            rangeAxis.setAxisLineVisible(false);
            rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
        }
    }
}